<!--index.wxml-->
<!-- 
  微信小程序Mustachey语法的应用场景, 类似Vue
  1. 绑定内容
  2. 绑定属性
  3. 运算(三元运算, 算术运算等)
 -->
<!-- 动态绑定内容: -->
<view>{{ info }}</view>
<!-- 动态绑定属性: -->
<image src="{{imgSrc}}" mode="widthFix"></image>
<!-- 三元运算: -->
<view>{{ randomNum1 >= 5 ? '数字大于等于5' : '数字小于5' }}</view>
<!-- 算数运算: -->
<view>{{ randomNum2 * 100 }}</view>

<!-- 
  事件: 渲染层到逻辑层的通信方式, 用户在渲染层触发事件, 事件传递到逻辑层进行业务处理
  小程序中常用事件
  tap 绑定方式 bindtap  类似click,手指触摸后离开
  inout 绑定方式bindinput  文本框的输入事件
  change 绑定方式bindchange  状态改变时触发
 -->
<!-- 
  事件对象的属性裂变
  事件回调触发时, 会收到一个事件对象event,  它的详细属性如下:
  属性           类型            说明
  type          String          事件类型 input等
  timeStamp     integer         页面打开直到触发事件所经过的毫秒数
  target(重要)   Object          触发事件的组件的一些属性值集合
  currentTarget  Object         当前组件的一些属性值集合
  detail(重要)   Object         额外的信息
  touches        Array          触摸事件, 当前停留在一屏幕中的触摸点信息的数组, 多个手指的触摸点信息等
  changedTouches Array          触摸事件, 当前事件触发时, 发生变化的触摸点信息的数组
-->
<!-- 
    注:
  1. target和currentTarget的区别: target是触发该事件的源头组件, 而currentTarget就是当前事件所绑定的组件, 如下
  点击内部的按钮时, 点击事件以冒泡的形式向外扩散, 也会触发外层的view的tap事件处理函数,此时对于外层的view来说
  (1). e.target指向的是当前正在触发事件的源头组件, 因此e.target是内部的按钮按键;
  (2). e.currentTarget指向的是当前正在触发事件的那个组件, 因此e.currentTarget是当前的view组件
-->
<view class="outer-view" bindtap="outerHandler">
  <button type="primary" bindtap="innerHandler">按钮</button>
</view>

<!-- 
  bindtap的语法格式
  在小程序中, 不存在HTML中的onclick鼠标点击事件, 而是通过tap事件来响应用户的触摸行为
  ① 通过bindtap可以为组件绑定tap触摸事件, 语法如上
  ② 在页面的.js文件中定义对应的事件处理函数, 和data平级, 事件参数通过形参event(一般简写成e)来接收
-->
<!-- 
  在事件处理函数中为data中的数据赋值
  通过调用this.setData(dataObject)方法, 可以给页面data中的数据重新赋值, 示例:
  changeCount() {
    this.setData({
      count: this.data.count + 1
    })
  }
-->
<view>
  {{ 'count: ' + count }}
  <button type="primary" bind:tap="countChange">count+1</button>
</view>

<!-- 
  事件传参: 小程序的事件传参比较特殊, 不能在绑定事件的同时为事件处理函数传参, 例如下面代码不能正常工作
    <button type="primary" bindTap="btnHandler(123)">事件传参</button>
    小程序会将bindTap属性值统一当做事件名称来处理, 相当于调用一个名为btnHandler(123)的事件处理函数
  正确操作: 为组件提供data-*的自定义属性传参, 其中*代表的是参数的名字, 示例如下:
-->
<button type="primary" bind:tap="btnHandler1" data-info="{{2}}">事件传参</button>
<!-- 
  此处info会被解析为参数的名字; 数值2会被解析为参数的值(如果省略了{{}}, 默认传递字符串格式)
  然后在事件处理函数中, 通过event.target.dataset.参数名 即可获取到具体参数的值
-->

<!-- 
  bindinput的语法格式
  在小程序中, 通过input事件来响应文本框的输入事件, 语法格式如下:
  ① 通过bindinput可以为文本框绑定输入事件
  ② 在事件处理函数中, 通过e.datail.value获取输入后的文本
-->
<input type="text" bindinput="inputHandler1"/>

<!-- 
  实现文本框和data之间的数据同步
  实现步骤: 
    ① 定义数据
    ② 渲染结构
    ③ 美化样式
    ④ 绑定input事件处理函数
-->
<view>
  {{ msg }}
</view>
<input type="text" value="{{msg}}" bindinput="inputHandler2"/>

<!-- 
  条件渲染
  1. wx:if
  小程序中, 使用wx:if="{{condition}}"来判断是否需要渲染该代码块
  也可以配合wx:else和wx:elif来添加else判断
-->
<view wx:if="{{type===1}}">男</view>
<view wx:elif="{{type===2}}">女</view>
<view wx:else>保密</view>

<!-- 
  结合<block>使用wx:if
  在小程序中, <block>并不是一个组件, 它只是一个包裹性质的容器, 不会在页面中做任何渲染
  因此, 如果要一次性控制多个组件的展示和隐藏, 可以使用一个<block></block>标签将多个组件包裹起来, 并在<block>标签上使用wx:if控制属性, 示例如下:
-->
<block wx:if="{{true}}">
  <view>view1</view>
  <view>view2</view>
</block>

<!-- 
  hidden
  在小程序中, 直接使用hidden="{{condition}}"也能控制元素的显示和隐藏
-->
<view hidden="{{ishidden}}" class="username">条件为true的时候隐藏元素否则显示</view>
<!-- 
  注: wx:if与hidden的对比
  wx:if以动态创建和移除元素的方式控制元素的显示和隐藏
  hidden以切换样式的方式(display: none/block)控制元素的显示和隐藏 性能更高, 频繁切换时建议使用
-->

<!-- 
  列表渲染
  wx:for可以根据指定的数组, 循环渲染重复的组件结构, 默认循环索引名为index, 项目变量名为item 语法示例如下:
-->
<view wx:for="{{arr1}}">
  索引是: {{index}} 当前项是: {{item}}
</view>
<!-- 
  注: 手动指定索引和当前项目的变量名:
  !. 使用wx:for-index="idx"可以指定当前循环项的索引的变量名
  2. 使用wx:for-item="itemName"可以指定当前项的变量名
-->
<view>~~~~~~~~~~~~~~</view>
<view wx:for="{{arr1}}" wx:for-index="spindex" wx:for-item="spitem">
  索引是: {{spindex}} 当前项是: {{spitem}}
</view>
<!--
  类似vue列表渲染的:key, 小程序实现列表渲染时也建议为渲染出来的列表项指定唯一的key值, 从而提高视图更新时的渲染效率
-->

<!-- 
  WXSS: WeiXin Style Sheet 
  WXSS是一套样式语言, 用于美化wxml的组件样式, 类似与网页开发中的CSS
  WCSS具有CSS大部分特性, 同时WXSS还对CSS进行了扩充和修改, 以适应微信小程序的开发:
    rpx尺寸单位
    @import样式导入
    但css选择器部分不兼容
-->
<!-- 
  1. rpx是微信小程序独有, 用来解决屏幕适配的尺寸单位
  2. rpx的实现原理:
    鉴于不同设备屏幕的大小不同, 为了实现屏幕的自动适配, rpx把所有设备的屏幕, 在宽度上等分为750份(即当前屏幕的总宽度为750rpx)
    导致: 
      1. 在较小设备上, 1rpx代表的宽度偏小 不常见
      2. 在较大的设备上, 1rpx代表的宽度较大
    小程序在不同设备上运行的时候, 会自动把rpx的样式单位换算成对应的像素单位来渲染, 从而实现屏幕适配
    小程序以iphone6作为视觉稿,
      iphone6, 屏幕宽度为375px, 共有750个物理像素, 等分为750rpx, 则1rpx=0.5px=1物理像素
-->

<!-- 
  样式导入
  使用WXSS提供的@import语法, 可以导入外联的样式表
  语法格式: @import后跟需要导入的外联样式表的相对路径, 用;表示语句结束
-->

<!-- 
  全局样式: 
    定义在app.wxml中的样式为全局样式, 作用于每一个页面
  局部样式:
    在页面的.wxml中的样式为局部样式, 仅作用于当前页面, 且注意:
    ① 当局部样式和 全局样式冲突时, 局部样式会覆盖全局样式
    ② 当局部样式的权重大于或等于全局样式的权重时, 才会覆盖全局样式
-->

<!-- 
  全局配置:
    小程序根目录下的app.json文件时小程序的全局配置文件, 常用的配置项如下:
    ① pages
      记录当前小程序所有页面的存放路径
    ② window
      全局设置小程序窗口的外观
    ③ tabBar
      设置小程序底部的tabBar效果
    ④ style
      是否启用新版的组件样式

  1.小程序窗口的三个组成部分:
    navigationBar 导航栏区域
    background 背景区域, 默认不可见, 下拉才显示
    页面主体区域, 用来显示wxml中的布局
  2.window节点常用的配置项:
    navigationBarTItleText String 字符串 导航栏标题文字内容
    navigationBarBackgroundColor HexColor #000000 导航栏背景颜色
    navigationBarTextStyle String white 导航栏标题颜色, 仅支持black/white
    backgroundColor HexColor #ffffff 窗口的背景色
    backgroundTextStyle String dark 下拉loading样式, 仅支持dark/light
    enablePullDownRefresh Boolean false 是否去全局开启下拉刷新
    onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离, 单位为px
  3. 全局开启下拉刷新功能
    概念: 下拉刷新时移动端的专有名词, 指的是通过手指在屏幕上的下拉滑动操作, 从而重新加载页面诗句的行为
    app.json -> window -> 把enablePullDownRefresh的值为true
    注: 但在app.json中启用下拉刷新功能, 会作用于每个小程序页面; 且模拟器效果和真机存在区别
    因此通常在页面的app.json单独使用
  4. 设置下拉刷新背景色
    当全局开启下拉刷新功能后, 默认的窗口颜色背景为白色, 如果自定义下拉窗口背景色, 设置步骤为app.json->window->为background指定16进制色值
  5. 设置下拉刷新时的loading样式:
    当全局开启下拉刷新功能后, 默认窗口的loading样式为白色, 如果要更改loading样式的效果, 设置步骤为 app>json -> window -> 为backgroundTextStyle 属性指定dark值
    注: backgroundTextStyle仅可选light/dark属性
  6. 设置上拉触底的距离:
    概念: 上拉触底是移动端的专有名词, 通过手指在屏幕上的上拉滑动操作, 从而加载更多数据的行为, 设置步骤为: app/json -> window -> 为onReachBottomDistance设置新的数值
    注: 默认距离是50px, 如果没有特殊需求, 使用默认值即可
  7. tabBar: 
    1.tabBar是移动端常见的页面效果, 用于实现多页面的快速切换, 小程序中通常分为顶部/底部tabBar
    注: 1. tabBar中只能配最少2个, 最多5个tab页签
        2. 当渲染顶部tabBar时, 不显示icon, 仅显示文本

    2.tabBar的6个组成部分
    ① backgroundColor: tabBar的背景色
    ② selectedIconPath: 选中时的图片路径
    ③ borderStyle: tabBar上边框的颜色
    ④ iconPath: 未选中时的图片路径
    ⑤ selectedColor: tab上的文字选中时的颜色
    ⑥ color: tab上文字的默认颜色

    3. tabBar节点的配置项
    position String 非必填 bottom tabBar的位置, 仅支持bottom/top
    borderStyle String 非必填 black tabBar上边框颜色, 仅支持black/white
    color HexColor 非必填   Tab上的默认颜色
    selectedColor HexColor 非必填   Tab上的文字选中时的颜色
    backgroundColor HexColor 非必填   TabBar的背景色
    list Array 必填     tab 页签的列表 最少2个, 最多5个tab
      每个tab项的配置选项:
      pagePath String 必填 页面路径, 页面必须在pages中预先定义
      text String 必填 tab上显示的文字
      iconPath String 非必填 未选中时的图标路径, 当position为top时, 不显示icon
      selectedIconPath String 非必填 选中时的图标路径, 当position为top时, 不显示icon
    注意: 在tabBar中配置的页面, 在app.json的pages中必须在第一顺位, 否则打开小程序首屏为当前pages第一个页面, 且不显示tabBar
-->

<!--
  1. 页面配置文件的作用
  小程序中, 每个页面都有自己的.json配置文件, 用来对当前页面的窗口外观, 页面效果等进行配置
  2. 页面配置文件和全局配置的关系
  样式冲突时, 以页面级别的.json配置文件为准, 从而实现小程序在全局配置后, 每个页面可以拥有特殊的窗口表现
  3. 页面配置中常用的配置项
  同全局配置:
  navigationBarTItleText String 字符串 导航栏标题文字内容
  navigationBarBackgroundColor HexColor #000000 导航栏背景颜色
  navigationBarTextStyle String white 导航栏标题颜色, 仅支持black/white
  backgroundColor HexColor #ffffff 窗口的背景色
  backgroundTextStyle String dark 下拉loading样式, 仅支持dark/light
  重要 enablePullDownRefresh Boolean false 是否去全局开启下拉刷新 
  onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离, 单位为px
-->

<!--
  1. 小程序中网络数据请求的限制
  由于安全性方面的考虑, 小程序官方对数据接口的请求做出了如下两个限制:
  ① 只能请求https类型的接口
  ② 必须将接口的域名添加到信任列表中
  2. 配置request合法域名
  登录微信开放平台 -> 开发与服务 -> 开发设置 -> 服务器域名 -> 修改request合法域名
  注意: 
    1. 域名只支持https协议
    2. 域名不能使用IP地址或localhost
    3. 域名必须经过ICP备案
    4. 服务器域名一个月内最多申请5次修改
  3. 发起GET请求
    调用微信小程序提供的顶级全局对象wx中的wx.request()方法, 可以发起GET数据请求, 示例代码如下:
    wx.request({
      url: 'https://applet-base-api-t.itheima.net/api/get', // 请求的接口地址, 必须基于https协议
      method: 'GET', // 请求的方式
      data: { // 发送到服务器的数据
        name: 'zs',
        age: 22
      },
      success: (res) => { // 请求成功之后的回调函数
        console.log(res)
      }
    })
  4. 发起POST请求
    调用微信小程序提供的顶级全局对象wx中的wx.request()方法, 可以发起POST数据请求, 示例代码如下:
    wx.request({
      url: 'https://applet-base-api-t.itheima.net/api/post', // 请求的接口地址, 必须基于https协议
      method: 'POST', // 请求的方式
      data: { // 发送到服务器的数据
        name: 'ls',
        gender: '男'
      },
      success: (res) => { // 请求成功之后的回调函数
        console.log(res)
      }
    })

  5. 在页面刚加载时请求数据
  在很多情况下, 我们需要在页面刚加载的时候自动请求一些初始化数据, 此时需要在页面的onLoad事件中调用获取数据的函数
  6. 跳过request合法域名校验
    如果调试开发过程中, 后端仅提供了http协议端口, 暂时没有提供https协议的接口, 此时为了不耽误开发进度, 可以在微信开发者工具中, 临时开启[开发环境不校验请求域名,TLS版本及HTTPS证书]选项, 跳过request合法域名的校验
  注: 该选项仅限在开发与调试阶段使用
  7. 关于跨域和Ajax的说明
  跨域问题只存在于基于浏览器的Web开发中, 由于小程序的宿主环境不是浏览器, 而是微信客户端, 因此小程序中不存在跨域的问题
  Ajax技术的核心是依赖于浏览器中的XMLHttpRequest这个对象, 由于小程序的宿主环境是微信客户端, 所以小程序中不能叫做发起Ajax请求, 而是叫做发起网络数据请求
-->

<!-- 
  小程序-视图与逻辑
  一. 页面导航
    1. 什么是页面导航
      页面导航指的是页面之间的相互跳转, 例如: 浏览器中实现页面导航的方式有如下两种:
      ① <a>链接
      ② location.href
    2. 小程序中实现页面导航的两种方式:
      ① 声明式导航
        在页面上声明一个<navigator>导航组件
        通过点击<navigator>组件实现页面跳转
      ② 编程式导航
        调用小程序的导航API, 实现页面的跳转
  二. 声明式导航
    1. 导航到tabBar页面
    tabBar页面指的是被配置为tabBar的页面
    在使用<navigator>组件跳转到指定的tabBar页面时, 需要指定url属性和open-type属性, 其中:
    url表示要跳转的页面的地址, 必须/开头
    open-type表示跳转的方式, 必须为switchTab 必填否则无法跳转
    示例: 
      <navigator url="/pages/message/message" open-type="switchTab">导航到消息页面</navigator>

    2. 导航到非tabBar页面
    非tabBar页面指的是没有被配置以为tabBar的页面
      <navigator url="/pages/logs/logs" open-type="navigate">导航到logs页面</navigator>
    但简写可省略open-type属性

    3. 后退导航
    如果要后退到上一页面或多级页面, 则需要指定open-type属性和delta属性, 其中:
    open-type的值必须是navigateBack, 表示要进行后退导航
    delta的值必须是数字, 表示要后退的层级
      <navigator open-type="navigatorBack" delta="1">返回上一页</navigator>
    但可以简写, 如果只是后退到上一级页面, 可以省略delta属性, 因为其默认值为1

  三. 编程式导航
  1. 导航到tabBar页面
  调用wx.switchTab(Object object)方法, 可以跳转到tabBar页面, 其中Object参数对象的属性列表如下:
    url string 必填 需要跳转的tabBar页面的路径, 路径后不能携带参数
    success function 非必填 接口调用成功的回调函数
    fail function 非必填 接口调用失败的回调函数
    complete function 非必填 接口调用结束的回调函数(成功失败都执行)
  示例如下:
    // 页面结构
    <button bindtap="gotoMessage">跳转到消息页面</button>
    // 通过编程式导航, 跳转到message页面
    gotoMessage() {
      wx.switchTab({
        url: '/pages/message/message'
      })
    }

  2. 导航到非tabBar页面
    调用wx.navigateTo(Object object)方法, 可以跳转到非tabBar页面, 其中Object参数对象的属性列表如下:
    url string 必填 需要跳转的tabBar页面的路径, 路径后不能携带参数
    success function 非必填 接口调用成功的回调函数
    fail function 非必填 接口调用失败的回调函数
    complete function 非必填 接口调用结束的回调函数(成功失败都执行)
  
  3. 后退导航
    调用wx.navigateBack(Object object), 可返回上一页面或多级页面, Object参数对象可选属性列表如下:
    delta number 非必填 返回的页面数, 如果delta大于现有页面数, 则返回到首页, 默认值为1
    success function 非必填 接口调用成功的回调函数
    fail function 非必填 接口调用失败的回调函数
    complete function 非必填 接口调用结束的回调函数(成功失败都执行)

  四. 导航传参
  1. 声明式导航传参
  navigator组件的url属性用来指定将要跳转的页面的路径, 同时路径的后面还可以携带参数:
    参数和路径之间使用?分割
    参数键与参数值用=相连
    不同参数用&分割
  2. 编程式导航传参
  同理, 调用wx.navigateTo(Object object)方法跳转页面时, 也可以携带参数, 代码实例如下
  wx.navigateTo({
    url: "/pages/logs/logs?name=" + this.data.aa + "&ids=" + this.data.bb,
  })
  3. 在onLoad()中获取导航传递的参数
  页面onLoad(options)声明周期形参options会自动接收导航传参

  五.下拉刷新事件
  1. 下拉刷新是移动端的专有名词, 指的是通过手指在屏幕上的下拉滑动操作, 从而重新加载页面数据的行为
  2. 启用下拉刷新:
    全局开启下拉刷新(不推荐): 在app.json的window节点中, 将enablePullDownRefresh设置为true
    局部开启下拉刷新: 在页面的.json配置文件中, 将enablePullDownRefresh设置为true
  3. 配置下拉刷新窗口的样式:
    在全局或页面的.json配置文件中, 通过backgroundColor(16进制颜色)和backgroundTextStyle(dark/light)来配置下拉刷新窗口的样式
  4. 监听页面的下拉刷新事件
    在页面的.js文件中, 通过onPullDownRefresh()函数即可监听当前页面的下拉刷新事件
  5. 停止下拉刷新的事件
    当处理完下拉刷新的回调函数后, 下拉刷新的loading效果会一直显示, 不会主动消失, 所以需要手动隐藏loading效果, 此时调用wx.stopPullDownRefresh()可以停止当前页面的下拉刷新

  六.上拉触底事件
  1. 上拉触底是移动端的专有名词, 通过手指在屏幕上的上拉滑动操作, 从而加载更多数据的行为
  2. 监听上拉触底事件, 示例代码如下:
    onReachBottom: function() {
      console.log('触发了上拉触底的事件')
    }
    注意对上拉事件进行节流处理, 在上一个请求未完成之前不允许触发事件
  3. 配置上拉触底距离
    上拉触底距离指的是触发上拉触底事件时, 滚动条距离页面底部的距离
    可在全局或页面的.json配置文件中, 通过onReachBottomDistance属性来配置上拉触底的距离, 默认为50px

  七.生命周期
  1. 生命周期是指一个对象从创建->运行->销毁的整个阶段, 强调的是一个时间段
  2. 生命周期分类
    ① 应用生命周期: 小程序从启动 -> 运行 -> 销毁的过程
    ② 页面生命周期: 小程序中每个页面的加载 -> 渲染 -> 销毁的过程
  3. 生命周期函数: 小程序提供的内置函数, 会伴随着生命周期自动按次序执行, 强调时间点
    允许开发人员在特定的时间点执行某些特定的操作
  4. 生命周期函数分类
    ① 应用的生命周期函数 整个应用的启动,运行,销毁
      在app.js中进行声明
      App({
        // 小程序初始化完成时执行此函数, 全局只触发一次, 可以进行一些初始化操作
        onLaunch: function(options) {},
        // 小程序启动, 或从后台进入前台显示时触发
        onShow: function(options) {},
        // 小程序从前台进入后台时触发,
        onHide: function() {}
      })
    ② 页面的生命周期函数
      页面的生命周期函数需要在页面的.js文件中进行声明:
      Page({
        onLoad: function(options) {}, // 监听页面加载, 一个页面只调用一次; 获取页面初始数据
        onShow: function() {}, // 监听页面显示
        onReady: function() {}, // 监听页面和初次渲染完成, 一个页面只调用一次; 修改页面相关样式, 比如修改标题和页面内容, 这些操作只能在页面渲染完成时进行
        onHide: function() {}, // 监听页面隐藏
        onUnload: function() {} // 监听页面卸载, 一个页面只调用一次
      })
-->

<!--
  WXS脚本
  1. WXS是小程序独有的一套脚本语言, 结合WXML可以构建出页面的结构
  2. 应用场景: 
    wxml中无法调用在页面的.js中定义的函数, 但是wxml中可以调用wxs中定义的函数, 因此小程序中的wxs的典型应用场景就是过滤器
  3. wxs和js的关系
  ① wxs有自己的数据类型
  number string boolean object function array date regexp
  ② wxs不支持类似于ES6及以上的语法形式
  不支持 let const 解构赋值 展开运算符 箭头函数 对象属性简写
  支持 var定义变量, 普通function函数等类似于ES5的语法
  ③ wxs遵循CommonJS规范
  module对象
  require()函数
  module.exports对象
  4. 内嵌wxs脚本
  wxs代码可以编写在wxml文件中的<wxs>标签内, 类似js代码可以编写在html文件中的<script>标签内一样
  但wxml文件中的每个<wxs></wxs>标签, 必须提供module属性, 用来指定当前wxs的模块名称, 方便在wxml中访问模块中的成员
  5. 外联的wxs脚本
  wxs代码还可以编写在以.wxs后缀的文件内, 就像js代码可以编写在以.js为后缀名的文件中一样
  定义: 
    function toLower(str) {
      return str.toLowerCase()
    }
    module.export = {
      toLower: toLower
    }
  使用: 
    在wxml中引入外联的wxs脚本时, 必须为<wxs>标签添加module和src属性, 其中:
    module用来指定模块的名称
    src用来指定要引入的脚本的路径, 且必须是相对路径
-->

<!-- 
  总结: 
    ① 页面之间的导航跳转:
      声明式导航, 编程式导航
    ② 实现下拉刷新效果
      enablePullDownRefresh, onPullDownRefresh
    ③ 实现上滑加载更多效果
      onReachBottomDistance, onReachBottom
    ④ 能够知道小程序中常用的生命周期函数
      应用生命周期函数: onLunch(重要), onShow, onHide
      页面生命周期函数: onLoad(重要), onShow, onReady(重要), onHide, onUnload
-->