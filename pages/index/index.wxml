<!--index.wxml-->
<!-- 
  微信小程序Mustachey语法的应用场景, 类似Vue
  1. 绑定内容
  2. 绑定属性
  3. 运算(三元运算, 算术运算等)
 -->
<!-- 动态绑定内容: -->
<view>{{ info }}</view>
<!-- 动态绑定属性: -->
<image src="{{imgSrc}}" mode="widthFix"></image>
<!-- 三元运算: -->
<view>{{ randomNum1 >= 5 ? '数字大于等于5' : '数字小于5' }}</view>
<!-- 算数运算: -->
<view>{{ randomNum2 * 100 }}</view>

<!-- 
  事件: 渲染层到逻辑层的通信方式, 用户在渲染层触发事件, 事件传递到逻辑层进行业务处理
  小程序中常用事件
  tap 绑定方式 bindtap  类似click,手指触摸后离开
  inout 绑定方式bindinput  文本框的输入事件
  change 绑定方式bindchange  状态改变时触发
 -->
<!-- 
  事件对象的属性裂变
  事件回调触发时, 会收到一个事件对象event,  它的详细属性如下:
  属性           类型            说明
  type          String          事件类型 input等
  timeStamp     integer         页面打开直到触发事件所经过的毫秒数
  target(重要)   Object          触发事件的组件的一些属性值集合
  currentTarget  Object         当前组件的一些属性值集合
  detail(重要)   Object         额外的信息
  touches        Array          触摸事件, 当前停留在一屏幕中的触摸点信息的数组, 多个手指的触摸点信息等
  changedTouches Array          触摸事件, 当前事件触发时, 发生变化的触摸点信息的数组
-->
<!-- 
    注:
  1. target和currentTarget的区别: target是触发该事件的源头组件, 而currentTarget就是当前事件所绑定的组件, 如下
  点击内部的按钮时, 点击事件以冒泡的形式向外扩散, 也会触发外层的view的tap事件处理函数,此时对于外层的view来说
  (1). e.target指向的是当前正在触发事件的源头组件, 因此e.target是内部的按钮按键;
  (2). e.currentTarget指向的是当前正在触发事件的那个组件, 因此e.currentTarget是当前的view组件
-->
<view class="outer-view" bindtap="outerHandler">
  <button type="primary" bindtap="innerHandler">按钮</button>
</view>

<!-- 
  bindtap的语法格式
  在小程序中, 不存在HTML中的onclick鼠标点击事件, 而是通过tap事件来响应用户的触摸行为
  ① 通过bindtap可以为组件绑定tap触摸事件, 语法如上
  ② 在页面的.js文件中定义对应的事件处理函数, 和data平级, 事件参数通过形参event(一般简写成e)来接收
-->
<!-- 
  在事件处理函数中为data中的数据赋值
  通过调用this.setData(dataObject)方法, 可以给页面data中的数据重新赋值, 示例:
  changeCount() {
    this.setData({
      count: this.data.count + 1
    })
  }
-->
<view>
  {{ 'count: ' + count }}
  <button type="primary" bind:tap="countChange">count+1</button>
</view>

<!-- 
  事件传参: 小程序的事件传参比较特殊, 不能在绑定事件的同时为事件处理函数传参, 例如下面代码不能正常工作
    <button type="primary" bindTap="btnHandler(123)">事件传参</button>
    小程序会将bindTap属性值统一当做事件名称来处理, 相当于调用一个名为btnHandler(123)的事件处理函数
  正确操作: 为组件提供data-*的自定义属性传参, 其中*代表的是参数的名字, 示例如下:
-->
<button type="primary" bind:tap="btnHandler1" data-info="{{2}}">事件传参</button>
<!-- 
  此处info会被解析为参数的名字; 数值2会被解析为参数的值(如果省略了{{}}, 默认传递字符串格式)
  然后在事件处理函数中, 通过event.target.dataset.参数名 即可获取到具体参数的值
-->

<!-- 
  bindinput的语法格式
  在小程序中, 通过input事件来响应文本框的输入事件, 语法格式如下:
  ① 通过bindinput可以为文本框绑定输入事件
  ② 在事件处理函数中, 通过e.datail.value获取输入后的文本
-->
<input type="text" bindinput="inputHandler1"/>

<!-- 
  实现文本框和data之间的数据同步
  实现步骤: 
    ① 定义数据
    ② 渲染结构
    ③ 美化样式
    ④ 绑定input事件处理函数
-->
<view>
  {{ msg }}
</view>
<input type="text" value="{{msg}}" bindinput="inputHandler2"/>

<!-- 
  条件渲染
  1. wx:if
  小程序中, 使用wx:if="{{condition}}"来判断是否需要渲染该代码块
  也可以配合wx:else和wx:elif来添加else判断
-->
<view wx:if="{{type===1}}">男</view>
<view wx:elif="{{type===2}}">女</view>
<view wx:else>保密</view>

<!-- 
  结合<block>使用wx:if
  在小程序中, <block>并不是一个组件, 它只是一个包裹性质的容器, 不会在页面中做任何渲染
  因此, 如果要一次性控制多个组件的展示和隐藏, 可以使用一个<block></block>标签将多个组件包裹起来, 并在<block>标签上使用wx:if控制属性, 示例如下:
-->
<block wx:if="{{true}}">
  <view>view1</view>
  <view>view2</view>
</block>

<!-- 
  hidden
  在小程序中, 直接使用hidden="{{condition}}"也能控制元素的显示和隐藏
-->
<view hidden="{{ishidden}}" class="username">条件为true的时候隐藏元素否则显示</view>
<!-- 
  注: wx:if与hidden的对比
  wx:if以动态创建和移除元素的方式控制元素的显示和隐藏
  hidden以切换样式的方式(display: none/block)控制元素的显示和隐藏 性能更高, 频繁切换时建议使用
-->

<!-- 
  列表渲染
  wx:for可以根据指定的数组, 循环渲染重复的组件结构, 默认循环索引名为index, 项目变量名为item 语法示例如下:
-->
<view wx:for="{{arr1}}">
  索引是: {{index}} 当前项是: {{item}}
</view>
<!-- 
  注: 手动指定索引和当前项目的变量名:
  !. 使用wx:for-index="idx"可以指定当前循环项的索引的变量名
  2. 使用wx:for-item="itemName"可以指定当前项的变量名
-->
<view>~~~~~~~~~~~~~~</view>
<view wx:for="{{arr1}}" wx:for-index="spindex" wx:for-item="spitem">
  索引是: {{spindex}} 当前项是: {{spitem}}
</view>
<!--
  类似vue列表渲染的:key, 小程序实现列表渲染时也建议为渲染出来的列表项指定唯一的key值, 从而提高视图更新时的渲染效率
-->

<!-- 
  WXSS: WeiXin Style Sheet 
  WXSS是一套样式语言, 用于美化wxml的组件样式, 类似与网页开发中的CSS
  WCSS具有CSS大部分特性, 同时WXSS还对CSS进行了扩充和修改, 以适应微信小程序的开发:
    rpx尺寸单位
    @import样式导入
    但css选择器部分不兼容
-->
<!-- 
  1. rpx是微信小程序独有, 用来解决屏幕适配的尺寸单位
  2. rpx的实现原理:
    鉴于不同设备屏幕的大小不同, 为了实现屏幕的自动适配, rpx把所有设备的屏幕, 在宽度上等分为750份(即当前屏幕的总宽度为750rpx)
    导致: 
      1. 在较小设备上, 1rpx代表的宽度偏小 不常见
      2. 在较大的设备上, 1rpx代表的宽度较大
    小程序在不同设备上运行的时候, 会自动把rpx的样式单位换算成对应的像素单位来渲染, 从而实现屏幕适配
    小程序以iphone6作为视觉稿,
      iphone6, 屏幕宽度为375px, 共有750个物理像素, 等分为750rpx, 则1rpx=0.5px=1物理像素
-->

<!-- 
  样式导入
  使用WXSS提供的@import语法, 可以导入外联的样式表
  语法格式: @import后跟需要导入的外联样式表的相对路径, 用;表示语句结束
-->

<!-- 
  全局样式: 
    定义在app.wxml中的样式为全局样式, 作用于每一个页面
  局部样式:
    在页面的.wxml中的样式为局部样式, 仅作用于当前页面, 且注意:
    ① 当局部样式和 全局样式冲突时, 局部样式会覆盖全局样式
    ② 当局部样式的权重大于或等于全局样式的权重时, 才会覆盖全局样式
-->

<!-- 
  全局配置:
    小程序根目录下的app.json文件时小程序的全局配置文件, 常用的配置项如下:
    ① pages
      记录当前小程序所有页面的存放路径
    ② window
      全局设置小程序窗口的外观
    ③ tabBar
      设置小程序底部的tabBar效果
    ④ style
      是否启用新版的组件样式

  1.小程序窗口的三个组成部分:
    navigationBar 导航栏区域
    background 背景区域, 默认不可见, 下拉才显示
    页面主体区域, 用来显示wxml中的布局
  2.window节点常用的配置项:
    navigationBarTItleText String 字符串 导航栏标题文字内容
    navigationBarBackgroundColor HexColor #000000 导航栏背景颜色
    navigationBarTextStyle String white 导航栏标题颜色, 仅支持black/white
    backgroundColor HexColor #ffffff 窗口的背景色
    backgroundTextStyle String dark 下拉loading样式, 仅支持dark/light
    enablePullDownRefresh Boolean false 是否去全局开启下拉刷新
    onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离, 单位为px
  3. 全局开启下拉刷新功能
    概念: 下拉刷新时移动端的专有名词, 指的是通过手指在屏幕上的下拉滑动操作, 从而重新加载页面诗句的行为
    app.json -> window -> 把enablePullDownRefresh的值为true
    注: 但在app.json中启用下拉刷新功能, 会作用于每个小程序页面; 且模拟器效果和真机存在区别
    因此通常在页面的app.json单独使用
  4. 设置下拉刷新背景色
    当全局开启下拉刷新功能后, 默认的窗口颜色背景为白色, 如果自定义下拉窗口背景色, 设置步骤为app.json->window->为background指定16进制色值
  5. 设置下拉刷新时的loading样式:
    当全局开启下拉刷新功能后, 默认窗口的loading样式为白色, 如果要更改loading样式的效果, 设置步骤为 app>json -> window -> 为backgroundTextStyle 属性指定dark值
    注: backgroundTextStyle仅可选light/dark属性
  6. 设置上拉触底的距离:
    概念: 上拉触底是移动端的专有名词, 通过手指在屏幕上的上拉滑动操作, 从而加载更多数据的行为, 设置步骤为: app/json -> window -> 为onReachBottomDistance设置新的数值
    注: 默认距离是50px, 如果没有特殊需求, 使用默认值即可
  7. tabBar: 
    1.tabBar是移动端常见的页面效果, 用于实现多页面的快速切换, 小程序中通常分为顶部/底部tabBar
    注: 1. tabBar中只能配最少2个, 最多5个tab页签
        2. 当渲染顶部tabBar时, 不显示icon, 仅显示文本

    2.tabBar的6个组成部分
    ① backgroundColor: tabBar的背景色
    ② selectedIconPath: 选中时的图片路径
    ③ borderStyle: tabBar上边框的颜色
    ④ iconPath: 未选中时的图片路径
    ⑤ selectedColor: tab上的文字选中时的颜色
    ⑥ color: tab上文字的默认颜色

    3. tabBar节点的配置项
    position String 非必填 bottom tabBar的位置, 仅支持bottom/top
    borderStyle String 非必填 black tabBar上边框颜色, 仅支持black/white
    color HexColor 非必填   Tab上的默认颜色
    selectedColor HexColor 非必填   Tab上的文字选中时的颜色
    backgroundColor HexColor 非必填   TabBar的背景色
    list Array 必填     tab 页签的列表 最少2个, 最多5个tab
      每个tab项的配置选项:
      pagePath String 必填 页面路径, 页面必须在pages中预先定义
      text String 必填 tab上显示的文字
      iconPath String 非必填 未选中时的图标路径, 当position为top时, 不显示icon
      selectedIconPath String 非必填 选中时的图标路径, 当position为top时, 不显示icon
    注意: 在tabBar中配置的页面, 在app.json的pages中必须在第一顺位, 否则打开小程序首屏为当前pages第一个页面, 且不显示tabBar
-->

<!--
  1. 页面配置文件的作用
  小程序中, 每个页面都有自己的.json配置文件, 用来对当前页面的窗口外观, 页面效果等进行配置
  2. 页面配置文件和全局配置的关系
  样式冲突时, 以页面级别的.json配置文件为准, 从而实现小程序在全局配置后, 每个页面可以拥有特殊的窗口表现
  3. 页面配置中常用的配置项
  同全局配置:
  navigationBarTItleText String 字符串 导航栏标题文字内容
  navigationBarBackgroundColor HexColor #000000 导航栏背景颜色
  navigationBarTextStyle String white 导航栏标题颜色, 仅支持black/white
  backgroundColor HexColor #ffffff 窗口的背景色
  backgroundTextStyle String dark 下拉loading样式, 仅支持dark/light
  重要 enablePullDownRefresh Boolean false 是否去全局开启下拉刷新 
  onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离, 单位为px
-->

<!--
  1. 小程序中网络数据请求的限制
  由于安全性方面的考虑, 小程序官方对数据接口的请求做出了如下两个限制:
  ① 只能请求https类型的接口
  ② 必须将接口的域名添加到信任列表中
  2. 配置request合法域名
  登录微信开放平台 -> 开发与服务 -> 开发设置 -> 服务器域名 -> 修改request合法域名
  注意: 
    1. 域名只支持https协议
    2. 域名不能使用IP地址或localhost
    3. 域名必须经过ICP备案
    4. 服务器域名一个月内最多申请5次修改
  3. 发起GET请求
    调用微信小程序提供的顶级全局对象wx中的wx.request()方法, 可以发起GET数据请求, 示例代码如下:
    wx.request({
      url: 'https://applet-base-api-t.itheima.net/api/get', // 请求的接口地址, 必须基于https协议
      method: 'GET', // 请求的方式
      data: { // 发送到服务器的数据
        name: 'zs',
        age: 22
      },
      success: (res) => { // 请求成功之后的回调函数
        console.log(res)
      }
    })
  4. 发起POST请求
    调用微信小程序提供的顶级全局对象wx中的wx.request()方法, 可以发起POST数据请求, 示例代码如下:
    wx.request({
      url: 'https://applet-base-api-t.itheima.net/api/post', // 请求的接口地址, 必须基于https协议
      method: 'POST', // 请求的方式
      data: { // 发送到服务器的数据
        name: 'ls',
        gender: '男'
      },
      success: (res) => { // 请求成功之后的回调函数
        console.log(res)
      }
    })

  5. 在页面刚加载时请求数据
  在很多情况下, 我们需要在页面刚加载的时候自动请求一些初始化数据, 此时需要在页面的onLoad事件中调用获取数据的函数
  6. 跳过request合法域名校验
    如果调试开发过程中, 后端仅提供了http协议端口, 暂时没有提供https协议的接口, 此时为了不耽误开发进度, 可以在微信开发者工具中, 临时开启[开发环境不校验请求域名,TLS版本及HTTPS证书]选项, 跳过request合法域名的校验
  注: 该选项仅限在开发与调试阶段使用
  7. 关于跨域和Ajax的说明
  跨域问题只存在于基于浏览器的Web开发中, 由于小程序的宿主环境不是浏览器, 而是微信客户端, 因此小程序中不存在跨域的问题
  Ajax技术的核心是依赖于浏览器中的XMLHttpRequest这个对象, 由于小程序的宿主环境是微信客户端, 所以小程序中不能叫做发起Ajax请求, 而是叫做发起网络数据请求
-->